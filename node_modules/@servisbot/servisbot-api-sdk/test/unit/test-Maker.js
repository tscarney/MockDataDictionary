/* eslint-disable no-template-curly-in-string */
const assert = require('assert');
const sinon = require('sinon');
const Promise = require('bluebird');
const logger = require('@servisbot/sb-logger');
const ServisBotApiSdk = require('../../src/ServisBotApiSdk');
const orchestratorFixture = require('../fixtures/orchestrator');

const api = ServisBotApiSdk(null, null, Promise, logger);

const emptyOrchestrator = () => {
  const myBusinessIntent = new api.Maker.BusinessIntent();
  const myResponseVoice = new api.Maker.ResponseVoice.GenericAdvisorResponse();
  const myPromptStrategy = new api.Maker.PromptStrategy.FlowStrategy();
  const contextMapping = { a: 1 };
  const myUserIntents = [];

  return new api.Maker.Orchestrator({
    businessIntent: myBusinessIntent,
    responseVoice: myResponseVoice,
    promptStrategy: myPromptStrategy,
    contextMapping,
    userIntents: myUserIntents
  });
};

describe('Maker', () => {
  describe('Orchestrator', () => {
    it('should create an Orchestrator, and associate the properties', () => {
      const orchestrator = emptyOrchestrator();
      assert.ok(orchestrator);
      const rV = orchestrator.responseVoice;
      assert.ok(rV instanceof api.Maker.ResponseVoice.GenericAdvisorResponse);
      assert.ok(orchestrator.promptStrategy instanceof api.Maker.PromptStrategy.FlowStrategy);
      assert.ok(orchestrator.contextMapping.a === 1);
    });
  });

  describe('Business Intent', () => {
    it('should create a Business Intent, and associate the properties', () => {
      const myApi = new api.BaaS.API({
        Alias: 'google',
        Endpoint: 'http://google.ie',
        RequestMapping: { paramA: '', paramB: '' }
      });
      const bslot1 = new api.Maker.BusinessSlot({
        name: 'bslot1',
        target: myApi.RequestMapping.paramA,
        validation: ''
      });
      const bslot2 = new api.Maker.BusinessSlot({
        name: 'bslot2',
        target: myApi.RequestMapping.paramB,
        validation: 'EURO, >1.00'
      });

      const businessIntent = new api.Maker.BusinessIntent({
        name: 'testBusinessIntent',
        api,
        businessSlots: [bslot1, bslot2]
      });
      assert.ok(businessIntent);
      assert.ok(businessIntent.api);
      assert.ok(businessIntent.businessSlots.length === 2);
    });
  });

  describe('User Intent', () => {
    it('should create User Intents with utterances', () => {
      const orchestrator = emptyOrchestrator();
      const uintent = new api.Maker.UserIntent({
        name: 'Name',
        description: 'Desc',
        utterances: ['Hi world, ${bS}', '${}']
      });
      assert.ok(uintent);
      orchestrator.userIntents.push(uintent);
      assert.ok(orchestrator.userIntents.length === 1);
    });

    it('should resolve user intents containing slots which do exist in the orchestrator', () => {
      const sourceAccountSlot = new api.Maker.BusinessSlot({ name: 'account' });
      sourceAccountSlot.addResolver('byNumber', new api.Maker.SlotType.Number());
      const businessIntent = new api.Maker.BusinessIntent({
        name: 'sendMoney',
        api: null,
        businessSlots: [sourceAccountSlot]
      });
      const userIntents = [
        new api.Maker.UserIntent({
          name: 'sendMoney',
          description: 'sends money',
          utterances: ['Send ${account} money']
        }),
      ];
      // It should accept slotted userIntents that exist in the BusinessIntent BusinessSlots
      const orchestrator = new api.Maker.Orchestrator({
        businessIntent,
        userIntents
      });
      assert.ok(orchestrator);
    });


    it('should reject User Intents containing slots which do not exist in the orchestrator', () => {
      const sourceAccountSlot = new api.Maker.BusinessSlot({ name: 'account' });
      sourceAccountSlot.addResolver('byNumber', new api.Maker.SlotType.Number());
      const foodSlot = new api.Maker.BusinessSlot({ name: 'food' });
      const businessIntent = new api.Maker.BusinessIntent({
        name: 'sendMoney',
        api: null,
        businessSlots: [sourceAccountSlot]
      });
      const userIntents = [
        new api.Maker.UserIntent({
          name: 'sendMoney',
          description: 'sends money',
          utterances: ['Send ${account} money']
        }),
      ];
      // It should accept slotted userIntents that exist in the BusinessIntent BusinessSlots
      const orchestrator = new api.Maker.Orchestrator({
        businessIntent,
        userIntents
      });
      assert.ok(orchestrator);
      // It should throw when the utterance contains slots
      // which don't exist in the Business Intent's Business Slots
      let caught = false;
      let o2;
      try {
        o2 = new api.Maker.Orchestrator({
          businessIntent: new api.Maker.BusinessIntent({
            name: 'sendFood',
            api: null,
            businessSlots: [foodSlot]
          }),
          userIntents
        });
      } catch (err) {
        assert.ok(err.message.includes('${account}'));
        assert.ok(!o2);
        caught = true;
      }
      assert.ok(caught);
    });
  }); // end User Intent

  describe('BusinessSlot', () => {
    it('should add resolvers to business slots', () => {
      const bslot1 = new api.Maker.BusinessSlot({ name: '' });
      const anythingSlotType = new api.Maker.SlotType.Date();
      bslot1.addResolver('byAnything', anythingSlotType);
      assert.ok(Object.keys(bslot1.resolvers).length === 1);
    });
  }); // end BusinessSlots

  describe('Response', () => {
    it('should create a Repsonse', () => {
      const response = new api.Maker.Response.MarkupResponse('<timeline><textMsg>Hi</textMsg></timeline>');
      assert.notDeepEqual(response.markup, null);
    });
  });

  describe('APIError', () => {
    it('should create a Repsonse', () => {
      const response = new api.Maker.APIError({ statusCode: 400, response: 'hello' });
      assert.notDeepEqual(response.response, null);
      assert.notDeepEqual(response.statusCode, null);
    });
  });

  describe('Language', () => {
    it('should create a Language', () => {
      const response = new api.Maker.Language('en');
      assert.deepEqual(response.ISOCode, 'en');
    });
    it('should not be possible to create a language that is not an ISO 639-1 standard code', () => {
      try {
        // eslint-disable-next-line
        new api.Maker.Language('zz');
        throw new Error('We should not be here');
      } catch (err) {
        assert.equal('Error: Invalid ISO Code Specified', err);
      }
    });
  });

  describe('Maker.API()', () => {
    it('should reject APIs from the catalog with duplicate names', () => {
      const catalog = new api.Maker.APICatalog();
      catalog.add('api1', new api.Maker.API('alias', 'http://servisbot.com/api', { paramA: '', paramB: '' }));
      try {
        catalog.add('api1', new api.Maker.API('alias', 'http://google.com/api', { paramA: '', paramB: '' }));
      } catch (err) {
        assert.ok(err);
      }
    });

    it('should add APIs to the API catalog', () => {
      const myApi1 = new api.Maker.API('alias', 'http://servisbot.com/api', { paramA: '', paramB: '' });
      const myApi2 = new api.Maker.API('alias', 'http://google.com/api', { paramA: '', paramB: '' });
      const catalog = new api.Maker.APICatalog();
      assert.ok(catalog);
      catalog.add('api1', myApi1);
      catalog.add('api2', myApi2);
      assert.ok(Object.keys(catalog.apis).length === 2);
      assert.ok(catalog.apis.api1 === myApi1);
    });
  }); // end API

  describe('Maker Utils', () => {
    it('Should import a serialized orchestrator', () => {
      const stubbedApi = ServisBotApiSdk(sinon.stub(), null, Promise, logger);
      const serialized = JSON.stringify(orchestratorFixture);
      const { Maker, BaaS } = stubbedApi;
      const orchestrator = stubbedApi.Maker.importOrchestrator(Maker, BaaS, JSON.parse(serialized));
      const { businessIntent, userIntents } = orchestrator;
      const { businessSlots } = businessIntent;
      assert.ok(businessIntent);
      assert.ok(businessIntent.api);
      assert.ok(businessIntent.api.endpoint);
      assert.ok(userIntents);
      assert.ok(businessSlots);
      const aSlot = businessSlots[0];
      const aResolver = aSlot.resolvers[0];
      assert.ok(aSlot.name);
      assert.ok(aResolver);
      assert.ok(aResolver.apiDefinition);
      assert.ok(aResolver.slotType);
      assert.ok(typeof aResolver.slotType.internal === 'boolean');
    });
    it('Should throw error for invalid number of arguments in importOrchestrator', () => {
      const stubbedApi = ServisBotApiSdk(sinon.stub(), null, Promise, logger);
      const { Maker } = stubbedApi;
      try {
        stubbedApi.Maker.importOrchestrator(Maker);
        assert.fail('Should not get here');
      } catch (e) {
        assert.strictEqual(e.message, 'Invalid number of arguments passed', 'Invalid message response');
      }
    });
    xit('can invoke a remote sync of workers for a bot.', () => {
    // const botId = 'testBotId';

    // setup a bot that has one BusinessIntent worker
    // api.Operator.syncWorkers(botId);

      assert.fail('not implemented yet');
    });
  }); // end Maker Utils

  describe('Maker.Conditional()', () => {
    it('should create a conditional', () => {
      const cond = new api.Maker.Conditional('a > b');
      assert.ok(cond);
    });

    it('should replace tripple equals', () => {
      const cond = new api.Maker.Conditional('a === b');
      assert.equal(cond.statement, 'a == b');
    });
  }); // end Conditional
});
