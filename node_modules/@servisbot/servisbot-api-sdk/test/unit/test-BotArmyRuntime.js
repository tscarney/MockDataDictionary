const assert = require('assert');
const sinon = require('sinon');
const Promise = require('bluebird');
const ServisBotApiSdk = require('../../src/ServisBotApiSdk');

describe('BotArmyRuntime', () => {
  it('should create a conversation from an R2 endpoint', () => {
    const endpoint = 'someorg-somebot';
    const customerReference = 'some-customer-ref';
    const context = { keyA: 'valueA' };
    const conversation = { ConversationId: 'some-conversation-id' };

    const fetch = sinon.stub()
      .resolves({ status: 200, json: () => Promise.resolve(conversation) });

    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://api.com', 'my-key')
      .then(() => api.BotArmyRuntime.createConversation(
        endpoint,
        customerReference,
        context,
        {}
      ))
      .then((res) => {
        assert.deepStrictEqual(
          res, conversation, 'Unexpected conversation data returned'
        );
        const { Endpoint: returnedEndpoint } = JSON.parse(fetch.getCall(0).args[1].body);
        assert.equal(returnedEndpoint, endpoint);
      })
      .catch((err) => {
        assert.fail(err);
      });
  });

  it('should reject if create conversation fails', () => {
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.createConversation('botId', 'customerRef'))
      .then(() => assert.fail('Promise should have rejected'))
      .catch((e) => {
        assert.ok(
          e.message.includes('forbidden'),
          'Error message should mention cause of failure'
        );
      });
  });

  it('should get a conversation by conversation id', () => {
    const conversationId = 'some-conversation-id';

    const conversation = {
      ConversationId: conversationId,
      CustomerReference: 'some-customer-reference',
      Context: {
        keyA: 'valueA'
      }
    };

    const fetch = sinon.stub()
      .resolves({ status: 200, json: () => Promise.resolve(conversation) });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => (
        api.BotArmyRuntime.getConversationByConversationId(conversationId)
      ))
      .then((res) => {
        assert.deepStrictEqual(
          res,
          conversation,
          'Unexpected conversation data returned'
        );
      })
      .catch((e) => {
        assert.fail(e);
      });
  });

  it('should reject if get conversation by id fails', () => {
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.getConversationByConversationId('convid'))
      .then(() => assert.fail('Promise should have rejected'))
      .catch((e) => {
        assert.ok(
          e.message.includes('forbidden'),
          'Error message should mention cause of failure'
        );
      });
  });

  it('should get a conversation by customer reference', () => {
    const customerReference = 'some-conversation-id';

    const conversation = {
      ConversationId: 'some-conversation-id',
      CustomerReference: customerReference,
      Context: {
        keyA: 'valueA'
      }
    };

    const fetch = sinon.stub()
      .resolves({ status: 200, json: () => Promise.resolve(conversation) });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => (
        api.BotArmyRuntime.getConversationByCustomerReference(customerReference)
      ))
      .then((res) => {
        assert.deepStrictEqual(
          res,
          conversation,
          'Unexpected conversation data returned'
        );
      })
      .catch((e) => {
        assert.fail(e);
      });
  });

  it('should reject if get conversation by customer reference fails', () => {
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.getConversationByCustomerReference('custRef'))
      .then(() => assert.fail('Promise should have rejected'))
      .catch((e) => {
        assert.ok(
          e.message.includes('forbidden'),
          'Error message should mention cause of failure'
        );
      });
  });

  it('should update a conversation', () => {
    const conversationId = 'some-conversation-id';
    const context = { keyA: 'valueA' };
    const state = 'PAUSE';
    const expectedResponse = { ConversationId: conversationId };

    const fetch = sinon.stub()
      .resolves({
        status: 200,
        json: () => Promise.resolve(expectedResponse)
      });
    const api = ServisBotApiSdk(fetch, Promise);


    return api.init('http://apiurl.com', 'api-key')
      .then(() => (
        api.BotArmyRuntime.updateConversation(conversationId, context, state)
      ))
      .then((res) => {
        assert.deepStrictEqual(
          res,
          expectedResponse,
          'Unexpected response'
        );
      })
      .catch((e) => {
        assert.fail(e);
      });
  });

  it('should reject if update conversation fails', () => {
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.updateConversation('convId', {}))
      .then(() => assert.fail('Promise should have rejected'))
      .catch((e) => {
        assert.ok(
          e.message.includes('forbidden'),
          'Error message should mention cause of failure'
        );
      });
  });

  it('should delete a conversation', () => {
    const conversationId = 'some-conversation-id';
    const expectedResponse = { ConversationId: conversationId };

    const fetch = sinon.stub()
      .resolves({
        status: 200,
        json: () => Promise.resolve(expectedResponse)
      });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.deleteConversation(conversationId))
      .then((res) => {
        assert.deepStrictEqual(
          res,
          expectedResponse,
          'Unexpected response'
        );
      })
      .catch((e) => {
        assert.fail(e);
      });
  });

  it('should reject if delete conversation fails', () => {
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.deleteConversation('convId'))
      .then(() => assert.fail('Promise should have rejected'))
      .catch((e) => {
        assert.ok(
          e.message.includes('forbidden'),
          'Error message should mention cause of failure'
        );
      });
  });

  it('should get all conversation messages and context', () => {
    const conversationId = 'some-conversation-id';
    const identity = 'some-identity';
    const expectedResponse = { context: {}, messages: [{ some: 'message' }, { another: 'message' }] };

    const fetch = sinon.stub().resolves({
      status: 200,
      json: () => Promise.resolve(expectedResponse)
    });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.getConversationDetails(conversationId, identity))
      .then(res => assert.deepStrictEqual(res, expectedResponse, 'Unexpected response'))
      .catch((e) => {
        assert.fail(e);
      });
  });

  it('should reject if getConversationDetails fails', () => {
    const conversationId = 'some-conversation-id';
    const identity = 'some-identity';
    const fetch = sinon.stub().resolves({ status: 403, statusText: 'forbidden' });
    const api = ServisBotApiSdk(fetch, Promise);

    return api.init('http://apiurl.com', 'api-key')
      .then(() => api.BotArmyRuntime.getConversationDetails(conversationId, identity))
      .then(() => assert.fail('Promise should have rejected'))
      .catch(e => assert.ok(e.message.includes('forbidden'), 'Error message should mention cause of failure'));
  });
});
