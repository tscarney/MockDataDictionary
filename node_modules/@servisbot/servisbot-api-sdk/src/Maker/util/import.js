module.exports = () => {
  const reconstructApiParam = (Maker, paramDefinition) => {
    const pType = paramDefinition.type;
    return new Maker.APIParam[pType](paramDefinition);
  };

  const reconstructMapping = (Maker, mappingObject) => {
    if (!mappingObject) {
      return {};
    }
    const newMapping = {};
    Object.keys(mappingObject).forEach((key) => {
      const oldMapping = mappingObject[key];
      newMapping[key] = reconstructApiParam(Maker, oldMapping);
    });
    return newMapping;
  };

  const reconstructApi = (Maker, BaaS, apiDefinitionToConstruct) => {
    const apiDefinition = apiDefinitionToConstruct;
    if (!apiDefinition || Object.keys(apiDefinition).length === 0) {
      return {};
    }
    const { requestMapping, responseMapping } = apiDefinition;
    apiDefinition.requestMapping = reconstructMapping(Maker, requestMapping);
    apiDefinition.responseMapping = reconstructMapping(Maker, responseMapping);
    if (apiDefinition.Alias) {
      return new BaaS.API(apiDefinition);
    }
    return new Maker.API(apiDefinition);
  };
  // eslint-disable-next-line func-names
  return function (Maker, BaaS, serializedOrchestrator) {
    if (arguments.length !== 3) {
      throw new Error('Invalid number of arguments passed');
    }
    if (typeof serializedOrchestrator !== 'object') {
      throw new Error('Orchestrators must be serialized JSON to be imported');
    }

    ['responseVoice', 'promptStrategy', 'businessIntent', 'userIntents'].forEach((requiredKey) => {
      if (!Object.keys(serializedOrchestrator).includes(requiredKey)) {
        throw new Error(`${requiredKey} must be specified when importing orchestrators`);
      }
    });

    const ResponseVoiceType = Maker.ResponseVoice[serializedOrchestrator.responseVoice.type];
    const responseVoice = new ResponseVoiceType(serializedOrchestrator.responseVoice);
    const PromptStrategyType = Maker.PromptStrategy[serializedOrchestrator.promptStrategy.type];
    const promptStrategy = new PromptStrategyType(serializedOrchestrator.promptStrategy);
    const contextMapping = { serializedOrchestrator };
    const UserIntents = serializedOrchestrator.userIntents.map(uI => new Maker.UserIntent(uI));
    let language;
    if (serializedOrchestrator.language) {
      language = new Maker.Language(serializedOrchestrator.language.ISOCode);
    }
    const businessSlots = serializedOrchestrator.businessIntent.businessSlots.map((bS) => {
      const slotToCreate = bS;
      if (slotToCreate.required && slotToCreate.required.type === 'conditional') {
        slotToCreate.required = new Maker.Conditional(slotToCreate.required.statement);
      }
      slotToCreate.resolvers = slotToCreate.resolvers.map((r) => {
        const localResolver = r;
        const SlotTypeConstructor = Maker.SlotType[localResolver.slotType.type];
        if (!SlotTypeConstructor) {
          throw new Error(`Slot type ${localResolver.slotType.type} not found!`);
        }
        localResolver.slotType = new SlotTypeConstructor(localResolver.slotType);
        localResolver.apiDefinition = reconstructApi(Maker, BaaS, localResolver.apiDefinition);
        localResolver.defaultApi = reconstructApi(Maker, BaaS, localResolver.defaultApi);
        return new Maker.Resolver(localResolver);
      });
      return new Maker.BusinessSlot(slotToCreate);
    });
    const api = reconstructApi(Maker, BaaS, serializedOrchestrator.businessIntent.api);
    const businessIntent = new Maker.BusinessIntent({
      ...serializedOrchestrator.businessIntent, businessSlots, api
    });
    return new Maker.Orchestrator({
      businessIntent,
      responseVoice,
      promptStrategy,
      contextMapping,
      userIntents: UserIntents,
      language
    });
  };
};
